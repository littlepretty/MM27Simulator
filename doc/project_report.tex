\documentclass[12pt]{article}  % [12pt] option for the benefit of aging markers

% amssymb package contains more mathematical symbols
\usepackage{amssymb,amsthm}

% graphicx package enables you to paste in graphics
\usepackage{graphicx}
\usepackage{auto-pst-pdf}
\usepackage{subfig}

% embed source inside latex
\usepackage[procnames]{listings}
\usepackage{color}

% ALGORITHM
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{enumitem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Page size commands.  Don't worry about these
%
\setlength{\textheight}{220mm}
\setlength{\topmargin}{-10mm}
\setlength{\textwidth}{150mm}
\setlength{\oddsidemargin}{0mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Definitions of environments for theorems etc.
%
\newtheorem{theorem}{Theorem}[section]          % Theorems numbered within sections - eg Theorem 2.1 in Section 2.
\newtheorem{corollary}[theorem]{Corollary}      % Corollaries etc. will be counted as Theorems for numbering
\newtheorem{lemma}[theorem]{Lemma}              % eg Lemma 3.1, ... Theorem 3.2, ... Corollary 3.3.
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{conjecture}[theorem]{Conjecture}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%        Preamble material specific to your essay
%
\title{Simulation of M/M/2/2+5 Queueing System}
\author{Jiaqi Yan, Ping Liu\\
CS555 Project\\
supervised by
Edward Chlebus}

\begin{document}
\maketitle

% \newpage                     % optional page break
\begin{abstract}
In this project, we simulate and analyze the M/M/2/2+5 queueing system. 
To generate generate packet arriving time and processing time, we use Python's built-in \textit{random} module, which is validated carefully.
Then we apply the \textbf{Welch graphical procedure} to eliminate the warm-up period in the simulation.
With the stationary region, we then analyze the system's properties such as blocking probability and mean number of packet in the system.
The 90\% confidence interval for these properties are also given.
\end{abstract}

% optional page break
\newpage
\tableofcontents

% optional page break
\newpage
\section{Discrete Event Simulation}\label{sec:des}
We designed and implemented our own simple simulator for M/M/2/2+5 queueing system.
The simulation workflow is shown in Algorithm \ref{alg:simulator}.
The whole process is embedded inside a while loop.

The while loop will keep consume event in the $event\_list$ until we handled all the packets.
Whenever there is unseen packets, we create an arrival event and insert it to the list.
This list thus should be maintained in order with respect to events' time stamp, which is determined as soon as we create a \texttt{event} object.
Also based on this time stamp, we will pop up the next event we should handle from the list according to the event type, either $arrival$ or $departure$.

If the type is $departure$, we first check number of arrived but waiting packets in the system.
When no packets need to be served at this moment, set the server this packet is leaving from to $idle$;
otherwise, just decrease this $waiting$ counter.
Anyway, we just served a packet.
This means the counter for served packet should increase.
We can also calculate the entire time this packet is in the system, from it entering until its exit, e.g. current clock.

For $arrival$ event, we have more cases to deal with.
Firstly, the system's queueing buffer may be already full when this arrival event happens;
this means the arriving packet is dropped and we just need to increase the counter $pkt\_dropped$. Notice that for this kind of arrival event, no corresponding $departure$ event needs to be scheduled.
However, as long as any system servers is available or the buffer can hold more packets, we need to properly create a corresponding $departure$ event and put it into the global event list.
The former case is easy to handle: we just find an available server, mark its status as $busy$ and record server ID to the event. 
The server ID will be used to unmark the $busy$ status when we handling this $departure$ event.
The time stamp of this newly created $departure$ event can be calculated by increasing the current clock time by the time it ought to be served, an exponential random value generated by our random generator.

When all servers are busy, we need to calculate the server who will serve the packet in the future and the time stamp at the end of the service differently.
Algorithm \ref{alg:schedule} shown the critical part of this task: find a server that will be available first.
Then this arrived packet should be served at this $earlier\_time\_stamp$ time point and on this first available server.
Therefore its departure time stamp should be this returned time stamp plus the duration it will be served in the server.


\begin{algorithm*}[t]
\caption{Core of Discrete Event Simulation}
\label{alg:simulator}
\begin{algorithmic}[1]
\Function{simulation\_core}{$arrive\_time\_seq$, $serve\_time\_seq$}
\State{let $arrive\_time\_seq$ denote the arriving time of each packet}
\State{let $serve\_time\_seq$ denote the service time of each packet}
\State{let $N$ denote the number of total packets}
\While{$pkt\_served + pkt\_dropped < N$}
    \If{$pkt\_seen < N$}\Comment{Insert new arrival event to event list}
        \State $ts \gets arrive\_time\_seq[pkt\_seen]$
        \State{Create new arrival event $evt$ with time stamp $ts$ and id $pkt\_seen$}
        \State{Insert $evt$ to $event\_list$}
    \EndIf
    \State{Sort $event\_list$ based on events' time stamp}
    \State{Pop up the next event $evt_x$ we need to handle in $event\_list$}
    \State{$clock \gets evt_x.time\_stamp$}
    \If{$evt_x$ is departure event}
        \If{queue buffer is empty}
            \State{Set the status of the server $evt_x$ is leaving to $idle$}
        \Else
            \State{$--waiting$}
        \EndIf
        \State{$++pkt\_served$}
        \State{$evt_x.exit\_time \gets clock$}
        \State{$spending\_time \gets evt_x.exit\_time - evt_x.enter\_time$}
        \State{Record the spending time of packet of event $evt_x$}
    \EndIf
    \If{$evt_x$ is arrival event}
        \If{queue buffer is full}
            \State{$++pkt\_dropped$}
        \Else
            \If{There is available server}
                \State $id \gets evt_x.pkt\_id$
                \State $ts \gets clock + $ exponential service time
                \State{Choose an available server $s$}
                \State{Mark $s$ as $busy$}
            \Else
                \State $(ts, s) \gets $\Call{schedule\_departure}{  }
                \State $ts \gets ts + $ exponential service time
                \State $++waiting$
            \EndIf
            \State{Create new departure event $evt$ with time stamp $ts$}
            \State{$evt.enter\_time \gets clock$}
            \State{$evt.depart\_srv \gets s$}
            \State{Insert $evt$ to $event\_list$}
        \EndIf
    \EndIf
\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm*}

\begin{algorithm*}[t]
\caption{Schedule Departure Event When Server is Unavailable but Buffer is Not Full}
\label{alg:schedule}
\begin{algorithmic}[1]
\Function{schedule\_departure}{}
\State{Sort $event\_list$}
\For{each server $s$ in the system}
    \State{Find the last $departure$ event $evt$ scheduled on this server $s$}
    \State{$earlier\_time\_stamp$ = \Call{MIN}{$earlier\_time\_stamp$, $evt.time\_stamp$}}
\EndFor
\State{Return $earlier\_time\_stamp$ and the corresponding $server\_id$}
\EndFunction
\end{algorithmic}
\end{algorithm*}


%\begin{center}
%\begin{tabular}{|r|r|r|r|r|r|r|}        % 7 columns, each right-justified
%\hline                                  % horizontal line between rows
 %& $R_1$ & $R_2$ & $R_3$ & $R_4$ & $R_5$ & $R_6$ \\ % header row
%\hline
%$R_1$ &   & 3 &   &   &    & \\
%\hline
%$R_2$ & 4 &   & 6 &   &    & \\
%\hline
%$R_3$ &   &   &   & 7 &    & \\
%\hline
%$R_4$ &   &   &   &   & 11 & \\
%\hline
%$R_5$ &   &   &   &   &    & 9 \\
%\hline
%$R_6$ &   & 8 & 5 &   &    & \\
%\hline
%\end{tabular}
%\end{center}

\section{Random Generator}
\subsection{Validation}
In M/M/2/2+5 queueing system, the number of packet arriving in a fixed interval follows \textbf{Poisson Distribution} and the service time for each packet follows \textbf{Exponential Distribution}.
These input data is generated by \textit{Numpy}'s \textit{random} module. Before running the simulator, it is important to test the wellness of this random generator.

We evaluate Numpy's random generator in two ways. First we generate random values follows uniform distribution and then plot their histogram.
As shown in Figure \ref{fig:uniform}, the number of random values falling into each interval is close to each other.
This means that the generated values are very close to uniformly distributed.
Besides, we compare the normalized histogram to the `best fit' curve of both uniform distribution and normal distribution in Figure \ref{fig:uniform} and \ref{fig:normal}.
From both figures we can say that the random generator generated random values of user-specified distribution.


\begin{figure}
\centering
        \includegraphics[scale=0.6]{rg_histogram.eps}
        \caption{Histogram of Uniform Random Values Generated by Numpy}
        \label{fig:uniform}
\end{figure}
\begin{figure}
        \centering
        \includegraphics[scale=0.6]{rg_fitness.eps}
        \caption{Comparison to Best Fit Curve for Normal Distribution}
        \label{fig:normal}
\end{figure}

To generate different random value sequences, we feed the random generator a seed, which is the integral value of system current time.
That is the number of seconds since \textbf{Unix Epoch}.
We generated two sequences of 1000000 numbers each and use \textbf{t-test} to test statistically are they significantly different from each other.


\section{Eliminate Warm-up Period}
Using Algorithm \ref{alg:simulator} as core, we run 5000 simulations for system A and system B under different initial states respectively.
For each simulation run, we inject 1000 packets into the system; the simulation terminates when these 1000 packets are all handled.
We choose to observe number of packets in the system during simulation.
Every time this system variable changes, we record its value and the happenning time moment.
After simulation, we process this log as follows.
First we create a observation time sequence with interval 1 magnitude less than arrival rate and ends at the finishing moment of the last departure event.
This ensure that we will not lost any accuracy.
For example, for system B where $\lambda=10$, the observation interval is 0.01.
Then based on the simulation log, we calculate the value of number of packet at every observation time point.
In this way we get the output for one simulation run.

We process all simulation logs and then can obtain 5000 simulation outputs.
Since simulation ends at different time, we only keep $m$ observations where $m = MIN$(length of all outputs).
Based on Welch graphical procedure, we average 5000 simulation outputs, observation by observation.
There are totally 4 cases to investigate: system A with 0 initial packets, system A with 7 initial packets, system B with 0 initial packets, system B with 4 initial packets.
All systems' Welch processing results are plotted in Figure \ref{fig:systemAinit0all}, Figure \ref{fig:systemAinit7all}, Figure \ref{fig:systemBinit0all} and Figure \ref{fig:systemBinit4all} respectively.

\begin{figure*}
\centering
\subfloat[\textbf{System A with 0 Initial Packets}]{
        \includegraphics[scale=0.4]{Lmda2Init0Avg5000.eps}
        \label{fig:systemAinit0all}
}
\hfill
\subfloat[\textbf{System A  with 7 Initial Packets}]{
        \includegraphics[scale=0.4]{Lmda2Init7Avg5000.eps}
        \label{fig:systemAinit7all}
}
\\
\subfloat[\textbf{System B with 0 Initial Packets}]
{
        \includegraphics[scale=0.4]{Lmda10Init0Avg5000.eps}
        \label{fig:systemBinit0all}
}
\hfill
\subfloat[\textbf{System B with 4 Initial Packets}]
{
        \includegraphics[scale=0.4]{Lmda10Init4Avg5000.eps}
        \label{fig:systemBinit4all}
}
\caption{\textbf{Average 5000 Simulation Runs}}
\end{figure*}

Since the nonstationary states only take up a very smal fraction of the entire output, we further zoom out the them in Figure \ref{fig:systemAinit0warmup}, Figure \ref{fig:systemAinit7warmup}, Figure \ref{fig:systemBinit0warmup} and Figure \ref{fig:systemBinit4warmup}.



\begin{figure*}
\centering
\subfloat[\textbf{System A with 0 Initial Packets}]{
        \includegraphics[scale=0.4]{Lmda2Init0OflAvg5000.eps}
        \label{fig:systemAinit0warmup}
}
\hfill
\subfloat[\textbf{System A  with 7 Initial Packets}]{
        \includegraphics[scale=0.4]{Lmda2Init7OflAvg5000.eps}
        \label{fig:systemAinit7warmup}
}
\\
\subfloat[\textbf{System B with 0 Initial Packets}]
{
        \includegraphics[scale=0.4]{Lmda10Init0OflAvg5000.eps}
        \label{fig:systemBinit0warmup}
}
\hfill
\subfloat[\textbf{System B with 4 Initial Packets}]
{
        \includegraphics[scale=0.4]{Lmda10Init4OflAvg5000.eps}
        \label{fig:systemBinit4warmup}
}
\caption{\textbf{Zoom out Nonstationary States}}
\end{figure*}




\section{System Properties at Stationary State}

\subsection{Blocking Probability}


\subsection{Mean Spending Time}


\subsection{Mean Number of Packet}





% Python code embedding configuration
%\definecolor{keywords}{RGB}{255,0,90}
%\definecolor{comments}{RGB}{0,0,113}
%\definecolor{red}{RGB}{160,0,0}
%\definecolor{green}{RGB}{0,150,0}
%\lstset{language=Python,
        %basicstyle=\ttfamily\small,
        %keywordstyle=\color{keywords},
        %commentstyle=\color{comments},
        %stringstyle=\color{red},
        %showstringspaces=false,
        %identifierstyle=\color{green},
        %procnamekeys={def,class,True},
        %frame=single,
        %numbers=left,
        %numbersep=5pt,
        %numberstyle=\tiny\color{blue},
        %rulecolor=\color{black},
        %caption={Simulation Discovery Process},
        %label=lst:while-loop,
        %language=Python,
%}
%\begin{lstlisting}
%while updated:
    %for r in routers:
        %for n in r.neighbors:
            %router_n = get_router_by_name(n, routers)
            %for n_name, n_row_col in router_n.topo.items():
                %n_msg = (n_name, n_row_col)
                %r.recv_msg(n_msg)
    %updated = False
    %for r in routers:
        %if r.update_topo_database():
            %updated = True
%\end{lstlisting}

%\begin{figure}[h]
%\centering
        %\includegraphics[width=0.8\textwidth, height=0.8\textheight]{progress.ps}
%\caption{Discovery Percentage as Function of Iteration for $R_1$ and $R_6$}
%\label{fig:progress}
%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Bibliography
%
%     Use an easy-to-remember tag for each entry - eg \bibitem{How97} for an article/book by Howie in 1997
%     To cite this publication in your text, write \cite{How97}.  To include more details such as
%     page, Chapter, Theorem numbers, use the form \cite[Theorem 6.3, page 42]{How97}.
%
%\begin{thebibliography}{99}

% 
% The usual convention for mathematical bibliographies is to list alphabetically
% by first-named author (then second, third  etc. author then date)
% websites with no author names should go by the site name
%


% Typical layout for reference to a journal article
%
%\bibitem{Bovey}
%J. D. Bovey, M. M. Dodson,                         % author(s)
%The Hausdorff dimension of systems of linear forms % article name
%{\em Acta Arithmetica}                             % journal name - italics
%{\bf 45}                                           % volume number - bold
%(1986), 337--358.                                   % (year), page range

%% Typical layout for reference to a book
%%
%\bibitem{Cassels}
%J. W. S. Cassels,                                  % author(s)
%{\em An Introduction to Diophantine Approximation},% title - italics
%Cambridge University Press, Cambridge, 1965.       % Publisher, place, date.

%% Typical layout for reference to a website
%%
%\bibitem{GAP}
%The GAP Group, GAP -- Groups, Algorithms, and Programming,  % Site name
%Version 4.5.6; 2012. % other information
%(http://www.gap-system.org)  % URL


%% Typical layout for reference to an online article
%%
%\bibitem{Howie}
%J. Howie,                                            % author(s)
%{\em Generalised triangle groups of type $(3,5,2)$}, % article name - italics
%http://arxiv.org/abs/1102.2073                       % URL
%(2011).                                              % (year)
%\end{thebibliography}

\end{document}
